### 前言

位运算作为一个极其帅气的操作，用它来解N皇后非常简洁高效，但是确实位运算不是一个好理解的解法，这篇题解希望我能写得足够清楚，帮助到还不理解这个帅气解法的同学。

我们先直接看代码，然后我再详细解释。

```java
    private int size;  
    private int count; //N皇后可能的解法数

    public int totalNQueens(int n) {
        count = 0;
        size = (1 << n) - 1;
        dfs(0, 0, 0);
        return count;
    }

    /**
     * 
     * @param row 当前这行的填充情况
     * @param ld  左对角线的填充情况
     * @param rd  有对角线的填充情况
     */
    private void dfs(int row, int ld, int rd) {
        if (row == size) {
            count++;
            return;
        }
        //取得现在可以填充的位置，1表示可以填充的，0表示已经填充过了
        int pos = size & (~(row | ld | rd));

        while (pos != 0) {
            //取得pos的最后一位1，也就是这轮需要填充的位置
            int p = pos & -pos; 
            //将pos的最后一位1置为0，表明我们将这个位置填充了
            pos &= pos - 1; 
            //下探到下一层
            dfs(row | p, (ld | p) << 1, (rd | p) >> 1);
            //这里的回溯不需要再做什么操作，因为我们的或操作是不
            //改变row, ld, rd的值的
        }
    }
```

我尽可能把能写注释的地方写了注释，现在我们来详细地分析这个代码，体会一下位运算的巧妙。

### N皇后Ⅱ 思路分析

解N皇后，我们惯常的想法就是用一个棋盘，然后用三个set也好数组也好，对列、左对角线和有对角线进行判重，最终的结果就是每一行放了一个皇后。

由此我们可以想到，既然最后的结果还是填进去N个皇后，只不过分布在不同的行里，那我们能不能把它压缩进一行呢？再进一步，填充不填充，就是两个状态，我们连一维数组都不用，用一个位（bit）表示就好了呀，1表示这没填呢可以放一个皇后，0表示这里填不了，已经放了一个皇后了。所以我们只需要N个位（bit）就足够了。

计算机里位肯定不是我们想要多少就用多少，都是按字节来分配空间的，一个字节八个位，像八皇后我们用一个字节就可以存储了。一般的皇后数目不会太多，要不然结果会大得吓死人，如果在面试中，大家一定要提前和面试官沟通，什么题都一样，先把题目的边界，数据量等等条件问清楚再开始写代码。

这里我们用四个字节，也就是一个 int 类型（32位）来记录皇后的放置情况。应对这道题是绰绰有余的。

先不考虑皇后都放在一行里要怎么去判重，我们先来想一个写DFS首先要思考的东西，terminator，也就是跳出递归的条件。N皇后Ⅱ 要求的是解法数量，所以当然我们找到一个解法就完成了一次递归任务，然后就可以返回了。

那什么样算是找到了一个解法呢？那就是把所有的位都填满了嘛，八皇后的结果就是八个位都是1，这就是一个完整解法，我们就可以把记录结果的`count++`了。二进制里八个位都是1，表示成十进制就是 2^8 - 1。

如果对这里的基础知识都有点问题的话，可以去看我写的这篇文章👉[位运算](https://blog.csdn.net/qq_45627684/article/details/104219331)，是用C语言写的，不过底层规则的都是一样的。

好了结束引流我们再回到正题上。细心的同学可能就想通了我代码里没写注释的地方。
![image.png](https://pic.leetcode-cn.com/1608693281-gTuAoM-image.png)

![image.png](https://pic.leetcode-cn.com/1608693300-vEysas-image.png)

我们用row去记录皇后放置的情况，最后如果有放置完了，结果就会是row的那N位都被填上了1，这就是我们边界条件以及size的定义的由来。

```java
    public int totalNQueens(int n) {
        count = 0;
        size = (1 << n) - 1;
        dfs(0, 0, 0);
        return count;
    }
```
函数的调用入口这里我再多补充一句，明明我们每次判重要判断的是列、左对角线和有对象，为什么我的dfs函数这里写的是row, ld（left diagonal）和 rd呢？
![image.png](https://pic.leetcode-cn.com/1608694338-CqaLPk-image.png)

因为我们每次传的row，就像我上面说的，要把二维的数组压成一维，就是原来这个皇后可能在第三行的第一列(2, 0)，另一个皇后在第五行的第二列(4,1)，还有一个皇后在第一行第四列(0, 3)，现在我们不要纵向的这个维度了，只记录每个皇后在哪一列，这样用一行就可以表示这三个皇后的位置，也就是(1, 1, 0, 1)，1表示放了皇后。

所以我们相当于传递参数是每次都传递了一行进去，第一次row是(0, 0, 0, 0)，放了一个皇后就变成了(0, 0, 0, 1)，再次递归下探，可能就变成了(0, 1, 0, 1)……

有没有发现，这里row虽然传递的是一行，但是其实也是相当于一个列的集合，对应位置有1，说明那一列已经有一个皇后了（不要忘了我们压缩了一维），就不能再放皇后了，这就是一个列的判重。

好了，现在基本的思路我们知道了，来看位运算是怎么处理判重这个麻烦事。

```java
    int pos = size & (~(row | ld | rd));

    while (pos != 0) {
        //取得pos的最后一位1，也就是这轮需要填充的位置
        int p = pos & -pos; 
        //将pos的最后一位1置为0，表明我们将这个位置填充了
        pos &= pos - 1; 
        //下探到下一层
        dfs(row | p, (ld | p) << 1, (rd | p) >> 1);
        //这里的回溯不需要再做什么操作，因为我们的或操作是不
        //改变row, ld, rd的值的
    }
```
核心逻辑就是这几句，现在我逐行来说。

首先，我们要得到可以填充的位置，现在row, ld, rd分别记录了列、左对角线、右对角线的spare位置，现在要得到这三个集合中重合的1的位置，这就是我们可以填充的地方，比如row是`0010`, ld是 `0100`, rd是 `0001`, `row | ld | rd = 0111`, 再将它们取反就得到了 `~(row | ld | rd) = 1000`,1 就是我们可以填的位置.

大家看到这里可能会觉得迷惑,既然或完取反就得到我们要填充的位置了,为什么还要再 size 与一下?`size & (~(row | ld | rd))`. 前面我是用4位二进制举的例子,大家看前面的定义可以知道,我们的row, ld, rd都是定义的整型类型(int), 也就是32位,这里我简化一下,将上面的例子拓成八位.


```java
row | ld | rd = 0000 0111
~(row | ld | rd) = 1111 1000
```

可以看到前面本来我们用不到的位置也被反成了1,但我们是不能使用那些位置的,不然就成了随便几个皇后而不是N皇后了,那怎么办呢,我们就可以想到前面定义的size,即size是N位全为1,比N位高的位全为0的状态,1 和 0 一与就成了0,我们就可以把超过N位的无用位置还是置为0.

还是用上面的例子,我们假设N = 4,即要排列四皇后,那么

```java
size = 0000 1111

size & (~(row | ld | rd)) = 0000 1111
                                &
                            1111 1000
                          = 0000 1000
```

现在我们就知道了, pos其实就是现在我们要进行填充的一个棋盘,得到了这个棋盘,我们现在可以开始放置皇后们了.

```java
int pos = size & (~(row | ld | rd));
```

在以往的方法中,我们要放置皇后的话,就是给一个`for`循环,然后一个位置一个位置试,这里也是一样的,只不过我们要找可以放的位置,就需要找到棋盘`pos`中的1,并且我们也得有一定顺序性,不能尝试相同的位置.那要怎么做呢?这就牵扯到了位运算的一个小技巧:

```
得到x的最后一位1: x & -x
```

这个也不难,要注意的是在计算机的操作中,都是操作的补码.正数的补码就是它自己,所以没关系,负数的补码就需要算一下了.我举个例子,比如我现在要得到`10`的最后一位1.

```
(-10)原码: 1000 1010   (首位是符号位)
(-10)补码: 1111 0110   (原码除符号位外按位取反然后加1)

10 & -10 = 0000 1010
               &
           1111 0110
         = 0000 0010 = 2
```
是不是还挺妙的?

好,现在找到了我们要放的位置,已经判重过了,所以这个皇后一定是安全的,那就放吧.在前面我们说了.1是可以放的,所以我们要把这个位置变成不可放的0,就要把这个位置(也就是pos最后一位1的位置)置为0. 

既然位运算可以取出最后一位1,当然也可以把最后一位1置为0啦,这里再补充一个置零的小技巧:
```
`将x的最后一位1置为0: x &= x-1;`
```
分析方法和上面一样,正数的原码就是它本身,所以没什么值得注意的地方,大家可以自己验证一下.这个技巧也可以去很方便的解比特位运算或者1的数量等题.

所以尝试放皇后的代码我们就可以理解了:

```java
    //pos为0说明没有1可以取出来了,也就是棋盘已经填完了
    while (pos != 0) {
        //取得pos的最后一位1，也就是这轮需要填充的位置
        int p = pos & -pos; 
        //将pos的最后一位1置为0，表明我们将这个位置填充了
        pos &= pos - 1; 
        //下探到下一层
        dfs(row | p, (ld | p) << 1, (rd | p) >> 1);
    }
```

最后我们再来看下探到下一层的操作,`row | p` 应该是好理解的, 0 | 1就是1嘛,比如我们上面举的例子.取10的最后一位1,得到了2,那么p就是2 (0010) ,然后我们拿2和原本的row与一下,假设row之前是0100的话, `0100 | 0010 = 0110`,到了下一轮检测空位置的时候,倒数第二位这个位置就不能再被填了,这就相当于我们把它加到了set里.

ld是左对角线,rd是有对角线,这两个就更好理解了. 还是用上面的例子,我们填了2对应的位置,也就是倒数第二位,左移就相当于占了它的左下角,右移相当于占了它的右下角.这里我为了清晰一点,就假设之前的row是0好了.

```java
//左移
row | p = 0000 | 0010      = 0010
(row | p) << 1 = 0010 << 1 = 0100

//右移
row | p = 0000 | 0010      = 0010
(row | p) >> 1 = 0010 >> 1 = 0001
```
有没有发现,通过左移右移我们就实现了对角线的判断.

最后附上去掉注释的N皇后Ⅱ的代码,一共就二十来行,非常简洁.

```java
    private int size;  
    private int count; 

    public int totalNQueens(int n) {
        count = 0;
        size = (1 << n) - 1;
        dfs(0, 0, 0);
        return count;
    }

    private void dfs(int row, int ld, int rd) {
        if (row == size) {
            count++;
            return;
        }
        int pos = size & (~(row | ld | rd));

        while (pos != 0) {
            int p = pos & -pos; 
            pos &= pos - 1; 
            dfs(row | p, (ld | p) << 1, (rd | p) >> 1);
        }
    }
```

### N皇后Ⅰ 

N皇后Ⅰ比N皇后Ⅱ要多了一步,就是要输出每一个解法,其实也很容易,我们多传进去一个完整的二维数组board进去, 在每次放置皇后的时候都直接将皇后放入棋盘,然后再递归回溯. 这里我们用位运算更多的是起到一个快速判重的作用,因为位运算是最快的操作,所以也会对N皇后Ⅰ的性能有一个大的改善,比起用HashSet判重的话.

代码的逻辑和上面的一样,我还是先将代码放出,然后讲解几个需要注意的地方.

```java
public List<List<String>> solveNQueens(int n) {
        if (n < 1) {
            return Collections.emptyList();
        }
        List<List<String>> res = new ArrayList<>();

        char[][] board = new char[n][n];
        
        for (char[] row : board) {
            Arrays.fill(row, '.');
        }

        dfs(board, 0, 0, 0, 0, res);

        return res;
    }

    private void dfs(char[][] board, int row, int col, int ld, int rd, List<List<String>> res) {
        if (row == board.length) {
            res.add(piant(board));
            return;
        }

        int pos = ((1 << board.length) - 1) & (~(col | ld | rd));

        while (pos != 0) {
            int p = pos & -pos;
            pos &= pos - 1;
            
            //换底公式，解析p对应的列的下标
            int idx = (int) (Math.log(p) / Math.log(2));

            board[row][idx] = 'Q';

            dfs(board, row + 1, col | p, (ld | p) << 1, (rd | p) >> 1, res);

            board[row][idx] = '.';
        }
    }

    private List<String> piant(char[][] board) {
        List<String> ret = new ArrayList<>();

        for (int i = 0; i < board.length; i++) {
            ret.add(new String(board[i]));
        }
        return ret;
    }
```

比起Ⅱ的代码,有几个地方我改动了一下,因为要在真的二维棋盘上放置皇后,所以还是需要一个变量(row) 来记录现在递归到了第几行, col 就替代了我们上面Ⅱ的代码中row的作用.

其他的改动其实没什么,都是常规操作,有一行代码可能大家会有疑问.

![image.png](https://pic.leetcode-cn.com/1608710635-cWsmoq-image.png)

因为我们的判重是在一个32位的数据上进行操作的,我们要找到对应的列数,就需要做一点小转换.

二进制的每一位都是2的幂数, 比如p = 2 (0010), 我们就可以知道这是倒数第二位, 皇后应该放在倒数第二列上. 所以很简单,只需要一个以2为底的log函数,我们就得到了对应的索引. 但是这里需要注意的是,Java里的`Math.log()` 函数的底数是 e,而我们要求的是以2为底的对数,这时候就需要高中的数学知识出场了.

![image.png](https://pic.leetcode-cn.com/1608711150-utuuQf-image.png)

所以`int idx = (int) (Math.log(p) / Math.log(2));`

因为N皇后的解法的都是对称的,所以我直接`board[row][idx] = 'Q';`
但是要知道这里的下标其实是从右往左数的,只不过它还要遍历到左边,所以`board.length - idx - i` 和 `idx`是等价的,我们无需去转变.

希望能帮助到大家.

另外,这篇题解是看了我训练营的同学的题解之后理解而成的,我加了一些自己的补充,感谢在前的珠玉,原文大家可以跳转去这个链接👇
[社群分享-算法学习心得&N皇后位运算讲解](https://blog.csdn.net/qq_36499794/article/details/111302095)